import { Files } from '../types';
import { ValidationError, validateGitHubToken, validateProjectName } from '../utils/validation';

const GITHUB_API_BASE = 'https://api.github.com';

async function githubApiRequest(endpoint: string, token: string, options: RequestInit = {}) {
  try {
    // Input validation
    if (!endpoint || typeof endpoint !== 'string') {
      throw new ValidationError('API endpoint is required');
    }
    
    if (!token || typeof token !== 'string') {
      throw new ValidationError('GitHub token is required');
    }
    
    // Validate endpoint format
    if (!endpoint.startsWith('/')) {
      throw new ValidationError('Invalid API endpoint format');
    }
    
    const headers = {
      'Authorization': `token ${token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
      ...options.headers,
    };

    const response = await fetch(`${GITHUB_API_BASE}${endpoint}`, { 
      ...options, 
      headers
    });

    if (!response.ok) {
      let errorMessage = `GitHub API error: ${response.status} ${response.statusText}`;
      
      try {
        const errorData = await response.json();
        errorMessage = errorData.message || errorMessage;
        
        // GitHub API often includes more details in an 'errors' array
        if (errorData.errors && Array.isArray(errorData.errors) && errorData.errors.length > 0) {
          const detailedErrors = errorData.errors
            .map((e: any) => e.message || JSON.stringify(e))
            .join(', ');
          errorMessage += `: ${detailedErrors}`;
        }
      } catch (parseError) {
        // If we can't parse the error response, use the status text
        console.warn('Failed to parse GitHub API error response:', parseError);
      }
      
      throw new Error(errorMessage);
    }

    // Handle cases where there is no response body (e.g., 204 No Content)
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.indexOf('application/json') !== -1) {
      return response.json();
    }
    return null;
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    
    // Handle network errors
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error('Network error: Unable to connect to GitHub API');
    }
    
    throw error;
  }
}

export async function verifyToken(token: string) {
  try {
    // Validate token format
    const validatedToken = validateGitHubToken(token);
    
    const user = await githubApiRequest('/user', validatedToken);
    
    if (!user || !user.login) {
      throw new Error('Invalid user data received from GitHub');
    }
    
    return user;
  } catch (error) {
    console.error('GitHub token verification failed:', error);
    
    if (error instanceof ValidationError) {
      throw error;
    }
    
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    if (errorMessage.includes('401')) {
      throw new Error('Invalid or expired Personal Access Token');
    }
    if (errorMessage.includes('403')) {
      throw new Error('GitHub token does not have sufficient permissions');
    }
    
    throw new Error(`Token verification failed: ${errorMessage}`);
  }
}

export async function createRepo(token: string, name: string, isPrivate: boolean) {
  try {
    // Input validation
    const validatedToken = validateGitHubToken(token);
    const validatedName = validateProjectName(name);
    
    if (typeof isPrivate !== 'boolean') {
      throw new ValidationError('isPrivate must be a boolean value');
    }
    
    // Additional GitHub-specific name validation
    if (validatedName.length > 100) {
      throw new ValidationError('Repository name must be 100 characters or less');
    }
    
    if (!/^[a-zA-Z0-9._-]+$/.test(validatedName)) {
      throw new ValidationError('Repository name contains invalid characters');
    }
    
    const repo = await githubApiRequest('/user/repos', validatedToken, {
      method: 'POST',
      body: JSON.stringify({
        name: validatedName,
        private: isPrivate,
        description: 'Project generated by MominAI',
        auto_init: true,
      }),
    });
    
    if (!repo || !repo.full_name) {
      throw new Error('Invalid repository data received from GitHub');
    }
    
    return repo;
  } catch (error) {
    console.error('GitHub repo creation failed:', error);
    
    if (error instanceof ValidationError) {
      throw error;
    }
    
    if (error instanceof Error) {
      const errorMessage = error.message.toLowerCase();
      
      if (errorMessage.includes('name already exists')) {
        throw new Error('A repository with this name already exists on your account');
      }
      if (errorMessage.includes('422')) {
        throw new Error('Invalid repository configuration');
      }
      if (errorMessage.includes('403')) {
        throw new Error('Insufficient permissions to create repository');
      }
      
      throw new Error(`Repository creation failed: ${error.message}`);
    }
    
    throw new Error('Failed to create repository due to an unknown error');
  }
}

export async function pushFiles(token: string, owner: string, repo: string, files: Files, message: string) {
  try {
    // Input validation
    const validatedToken = validateGitHubToken(token);
    
    if (!owner || typeof owner !== 'string' || owner.trim().length === 0) {
      throw new ValidationError('Repository owner is required');
    }
    
    if (!repo || typeof repo !== 'string' || repo.trim().length === 0) {
      throw new ValidationError('Repository name is required');
    }
    
    if (!message || typeof message !== 'string' || message.trim().length === 0) {
      throw new ValidationError('Commit message is required');
    }
    
    if (!files || typeof files !== 'object' || Object.keys(files).length === 0) {
      throw new ValidationError('Files object is required and cannot be empty');
    }
    
    // Validate each file
    Object.entries(files).forEach(([path, content]) => {
      if (!path || typeof path !== 'string') {
        throw new ValidationError('Invalid file path');
      }
      if (typeof content !== 'string') {
        throw new ValidationError(`Invalid content for file: ${path}`);
      }
    });
    
    const sanitizedOwner = owner.trim();
    const sanitizedRepo = repo.trim();
    const sanitizedMessage = message.trim();
    
    // 1. Get the latest commit SHA of the main branch
    const branch = await githubApiRequest(`/repos/${sanitizedOwner}/${sanitizedRepo}/branches/main`, validatedToken);
    
    if (!branch || !branch.commit || !branch.commit.sha) {
      throw new Error('Unable to retrieve branch information');
    }
    
    const latestCommitSha = branch.commit.sha;
    const baseTreeSha = branch.commit.commit.tree.sha;

    // 2. Create a blob for each file
    const blobCreationPromises = Object.entries(files).map(async ([path, content]) => {
      try {
        const blob = await githubApiRequest(`/repos/${sanitizedOwner}/${sanitizedRepo}/git/blobs`, validatedToken, {
          method: 'POST',
          body: JSON.stringify({ content, encoding: 'utf-8' }),
        });
        
        if (!blob || !blob.sha) {
          throw new Error(`Failed to create blob for file: ${path}`);
        }
        
        return { path, sha: blob.sha, mode: '100644', type: 'blob' };
      } catch (error) {
        throw new Error(`Failed to create blob for ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    });
    
    const treeItems = await Promise.all(blobCreationPromises);

    // 3. Create a new tree with the new file blobs
    const newTree = await githubApiRequest(`/repos/${sanitizedOwner}/${sanitizedRepo}/git/trees`, validatedToken, {
      method: 'POST',
      body: JSON.stringify({
        base_tree: baseTreeSha,
        tree: treeItems,
      }),
    });
    
    if (!newTree || !newTree.sha) {
      throw new Error('Failed to create new tree');
    }
    
    // 4. Create a new commit pointing to the new tree
    const newCommit = await githubApiRequest(`/repos/${sanitizedOwner}/${sanitizedRepo}/git/commits`, validatedToken, {
      method: 'POST',
      body: JSON.stringify({
        message: sanitizedMessage,
        tree: newTree.sha,
        parents: [latestCommitSha],
      }),
    });
    
    if (!newCommit || !newCommit.sha) {
      throw new Error('Failed to create new commit');
    }

    // 5. Update the branch reference to point to the new commit
    await githubApiRequest(`/repos/${sanitizedOwner}/${sanitizedRepo}/git/refs/heads/main`, validatedToken, {
      method: 'PATCH',
      body: JSON.stringify({
        sha: newCommit.sha,
      }),
    });
    
  } catch (error) {
    console.error('GitHub push files failed:', error);
    
    if (error instanceof ValidationError) {
      throw error;
    }
    
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    throw new Error(`Failed to push files to GitHub: ${errorMessage}`);
  }
}
